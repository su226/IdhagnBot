from util.config import BaseState, Field
from aiohttp import ClientSession, ClientConnectionError
from nonebot.adapters.onebot.v11 import MessageSegment
from nonebot.params import CommandArg
from nonebot.log import logger
import nonebot
import os

class State(BaseState):
  __file__ = "emojimix"
  unsupported: set[str] = Field(default_factory=set)

CACHE_DIR = "states/emojimix_cache"
os.makedirs(CACHE_DIR, exist_ok=True)
def write_cache(cache: str, data: bytes):
  try:
    with open(cache, "wb") as f:
      f.write(data)
  except:
    logger.exception(f"å†™å…¥ç¼“å­˜å¤±è´¥ï¼š{cache}")

STATE = State.load()
API = "https://www.gstatic.com/android/keyboard/emojikitchen"
EMOJIS = {
  'â˜•': '20201001',
  'â›„': '20201001',
  'â¤ï¸\u200dğŸ©¹': '20210218',
  'â­': '20201001',
  'ğŸŒ‡': '20210831',
  'ğŸŒˆ': '20201001',
  'ğŸŒ': '20201001',
  'ğŸŒ›': '20201001',
  'ğŸŒœ': '20201001',
  'ğŸŒ': '20201001',
  'ğŸŒŸ': '20201001',
  'ğŸŒ­': '20201001',
  'ğŸŒ²': '20201001',
  'ğŸŒµ': '20201001',
  'ğŸŒ·': '20201001',
  'ğŸŒ¸': '20210218',
  'ğŸŒ¹': '20201001',
  'ğŸŒ¼': '20201001',
  'ğŸŠ': '20211115',
  'ğŸ‹': '20210521',
  'ğŸŒ': '20211115',
  'ğŸ': '20201001',
  'ğŸ“': '20210831',
  'ğŸ': '20210831',
  'ğŸ': '20211115',
  'ğŸ‚': '20201001',
  'ğŸƒ': '20201001',
  'ğŸˆ': '20201001',
  'ğŸŠ': '20201001',
  'ğŸ§': '20210521',
  'ğŸ†': '20211115',
  'ğŸŒ': '20210218',
  'ğŸ': '20210831',
  'ğŸ™': '20201001',
  'ğŸ': '20201001',
  'ğŸŸ': '20210831',
  'ğŸ¢': '20201001',
  'ğŸ¦': '20210831',
  'ğŸ§': '20211115',
  'ğŸ¨': '20201001',
  'ğŸ©': '20211115',
  'ğŸ­': '20201001',
  'ğŸ¯': '20220110',
  'ğŸ°': '20201001',
  'ğŸ±': '20201001',
  'ğŸµ': '20201001',
  'ğŸ¶': '20211115',
  'ğŸ·': '20201001',
  'ğŸ»': '20210831',
  'ğŸ¼': '20201001',
  'ğŸ‘€': '20201001',
  'ğŸ‘‘': '20201001',
  'ğŸ‘»': '20201001',
  'ğŸ‘½': '20201001',
  'ğŸ‘¿': '20201001',
  'ğŸ’€': '20201001',
  'ğŸ’‹': '20201001',
  'ğŸ’Œ': '20201001',
  'ğŸ’': '20201001',
  'ğŸ’': '20201001',
  'ğŸ’“': '20201001',
  'ğŸ’”': '20201001',
  'ğŸ’•': '20201001',
  'ğŸ’–': '20201001',
  'ğŸ’—': '20201001',
  'ğŸ’˜': '20201001',
  'ğŸ’™': '20201001',
  'ğŸ’š': '20201001',
  'ğŸ’›': '20201001',
  'ğŸ’œ': '20201001',
  'ğŸ’': '20201001',
  'ğŸ’': '20201001',
  'ğŸ’Ÿ': '20201001',
  'ğŸ’©': '20201001',
  'ğŸ’«': '20201001',
  'ğŸ’¯': '20201001',
  'ğŸ“°': '20201001',
  'ğŸ”¥': '20201001',
  'ğŸ”®': '20201001',
  'ğŸ–¤': '20201001',
  'ğŸ˜€': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜‚': '20201001',
  'ğŸ˜ƒ': '20201001',
  'ğŸ˜„': '20201001',
  'ğŸ˜…': '20201001',
  'ğŸ˜†': '20201001',
  'ğŸ˜‡': '20201001',
  'ğŸ˜ˆ': '20201001',
  'ğŸ˜‰': '20201001',
  'ğŸ˜Š': '20201001',
  'ğŸ˜‹': '20201001',
  'ğŸ˜Œ': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜‘': '20201001',
  'ğŸ˜’': '20201001',
  'ğŸ˜“': '20201001',
  'ğŸ˜”': '20201001',
  'ğŸ˜•': '20201001',
  'ğŸ˜–': '20201001',
  'ğŸ˜—': '20201001',
  'ğŸ˜˜': '20201001',
  'ğŸ˜™': '20201001',
  'ğŸ˜š': '20201001',
  'ğŸ˜›': '20201001',
  'ğŸ˜œ': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜': '20201001',
  'ğŸ˜Ÿ': '20201001',
  'ğŸ˜ ': '20201001',
  'ğŸ˜¡': '20201001',
  'ğŸ˜¢': '20201001',
  'ğŸ˜£': '20201001',
  'ğŸ˜¤': '20201001',
  'ğŸ˜¥': '20201001',
  'ğŸ˜¦': '20201001',
  'ğŸ˜§': '20201001',
  'ğŸ˜¨': '20201001',
  'ğŸ˜©': '20201001',
  'ğŸ˜ª': '20201001',
  'ğŸ˜«': '20201001',
  'ğŸ˜¬': '20201001',
  'ğŸ˜­': '20201001',
  'ğŸ˜®': '20201001',
  'ğŸ˜®\u200dğŸ’¨': '20210218',
  'ğŸ˜¯': '20201001',
  'ğŸ˜°': '20201001',
  'ğŸ˜±': '20201001',
  'ğŸ˜²': '20201001',
  'ğŸ˜³': '20201001',
  'ğŸ˜´': '20201001',
  'ğŸ˜µ': '20201001',
  'ğŸ˜¶': '20201001',
  'ğŸ˜¶\u200dğŸŒ«ï¸': '20210218',
  'ğŸ˜·': '20201001',
  'ğŸ™': '20201001',
  'ğŸ™‚': '20201001',
  'ğŸ™ƒ': '20201001',
  'ğŸ™„': '20201001',
  'ğŸ™ˆ': '20201001',
  'ğŸ¤': '20201001',
  'ğŸ¤': '20201001',
  'ğŸ¤': '20201001',
  'ğŸ¤‘': '20201001',
  'ğŸ¤’': '20201001',
  'ğŸ¤“': '20201001',
  'ğŸ¤”': '20201001',
  'ğŸ¤•': '20201001',
  'ğŸ¤–': '20201001',
  'ğŸ¤—': '20201001',
  'ğŸ¤ ': '20201001',
  'ğŸ¤¡': '20201001',
  'ğŸ¤¢': '20201001',
  'ğŸ¤£': '20201001',
  'ğŸ¤¤': '20201001',
  'ğŸ¤¥': '20201001',
  'ğŸ¤§': '20201001',
  'ğŸ¤¨': '20201001',
  'ğŸ¤©': '20201001',
  'ğŸ¤ª': '20201001',
  'ğŸ¤«': '20201001',
  'ğŸ¤¬': '20201001',
  'ğŸ¤­': '20201001',
  'ğŸ¤®': '20201001',
  'ğŸ¤¯': '20201001',
  'ğŸ¥‘': '20201001',
  'ğŸ¥°': '20201001',
  'ğŸ¥±': '20201001',
  'ğŸ¥²': '20201001',
  'ğŸ¥³': '20201001',
  'ğŸ¥´': '20201001',
  'ğŸ¥µ': '20201001',
  'ğŸ¥¶': '20201001',
  'ğŸ¥¸': '20201001',
  '\U0001f979': '20211115',
  'ğŸ¥º': '20201001',
  'ğŸ¦': '20201001',
  'ğŸ¦‚': '20210218',
  'ğŸ¦„': '20210831',
  'ğŸ¦‡': '20201001',
  'ğŸ¦‰': '20210831',
  'ğŸ¦Œ': '20201001',
  'ğŸ¦”': '20201001',
  'ğŸ¦™': '20201001',
  'ğŸ¦': '20211115',
  'ğŸ¦ ': '20201001',
  'ğŸ¦¥': '20201001',
  'ğŸ§€': '20201001',
  'ğŸ§': '20201001',
  'ğŸ§': '20201001',
  'ğŸ§¡': '20201001',
  'ğŸª„': '20210521',
  'ğŸªµ': '20211115',
  '\U0001fae0': '20211115',
  '\U0001fae1': '20211115',
  '\U0001fae2': '20211115',
  '\U0001fae3': '20211115',
  '\U0001fae4': '20211115',
  '\U0001fae5': '20211115'
}
def get_code(emoji: str) -> str:
  return "_".join(map(lambda ch: "u{:x}".format(ord(ch)), emoji))
SUPPORTED_STR = "æ”¯æŒçš„ emojiï¼ˆå¹¶ä¸æ˜¯æ‰€æœ‰ç»„åˆéƒ½å­˜åœ¨ï¼‰ï¼š\n" + "\n".join(map(lambda x: f"{x}ï¼ˆ{get_code(x)}ï¼‰", EMOJIS.keys()))

emojimix = nonebot.on_command("emojimix", aliases={"ç¼åˆ", "emoji", "mix"})
emojimix.__cmd__ = ["emojimix", "ç¼åˆ", "emoji", "mix"]
emojimix.__brief__ = "ç¼åˆä¸¤ä¸ªemoji"
emojimix.__doc__ = '''\
/emojimix - æŸ¥çœ‹æ”¯æŒçš„emoji
/emojimix <emoji1>+<emoji2> - ç¼åˆä¸¤ä¸ªemoji
æ•°æ®æ¥è‡ª https://tikolu.net/emojimix
å›¾ç‰‡æ¥è‡ª Google'''
@emojimix.handle()
async def handle_emojimix(args = CommandArg()):
  emojis = args.extract_plain_text().split("+")
  if len(emojis) == 0:
    await emojimix.finish(SUPPORTED_STR)
  elif len(emojis) != 2:
    await emojimix.finish("è¯·è¾“å…¥åŠ å·åˆ†å‰²çš„ä¸¤ä¸ª emoji")
  emoji1, emoji2 = emojis
  code1 = get_code(emoji1)
  code2 = get_code(emoji2)
  file1 = f"{code1}_{code2}"
  file2 = f"{code2}_{code1}"
  cache1 = os.path.abspath(f"{CACHE_DIR}/{file1}.png")
  cache2 = os.path.abspath(f"{CACHE_DIR}/{file2}.png")
  if os.path.exists(cache1):
    await emojimix.finish(MessageSegment.image("file://" + cache1))
  if os.path.exists(cache2):
    await emojimix.finish(MessageSegment.image("file://" + cache2))
  if file1 in STATE.unsupported:
    await emojimix.finish("ç»„åˆä¸å­˜åœ¨")
  if file2 in STATE.unsupported:
    await emojimix.finish("ç»„åˆä¸å­˜åœ¨")
  errors = []
  if emoji1 not in EMOJIS:
    errors.append(f"ä¸æ”¯æŒ {emoji1}ï¼ˆ{code1}ï¼‰")
  if emoji2 not in EMOJIS:
    errors.append(f"ä¸æ”¯æŒ {emoji2}ï¼ˆ{code2}ï¼‰")
  if errors:
    await emojimix.finish("\n".join(errors))
  async with ClientSession() as http:
    try:
      response = await http.get(f"{API}/{EMOJIS[emoji1]}/{code1}/{file1}.png")
      if response.status == 200:
        image = await response.read()
        write_cache(cache1, image)
        await emojimix.finish(MessageSegment.image(image))
      response = await http.get(f"{API}/{EMOJIS[emoji2]}/{code2}/{file2}.png")
      if response.status == 200:
        image = await response.read()
        write_cache(cache2, image)
        await emojimix.finish(MessageSegment.image(image))
      STATE.unsupported.add(file1)
      STATE.dump()
      await emojimix.finish("ç»„åˆä¸å­˜åœ¨")
    except ClientConnectionError:
      await emojimix.finish("ç½‘ç»œé”™è¯¯")
